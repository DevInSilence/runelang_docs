## Language components

For this language we are going to split it into multiple smaller components. Each component is responsible for a specific task. We do this to separate concerns and make the code easier to manage. The components are as follows:

1. **Lexer**: This component is responsible for tokenizing the input source code.
2. **Parser**: This component is responsible for parsing the tokens generated by the lexer and building an abstract syntax tree (AST).
3. **Analyzer**: This component is responsible for analyzing the AST and basic source code optimizations.

Finally, we will get to: *"What are we going todo with the AST?"*. There are different ways to use the AST.

### Interpreter vs. Compiler vs. Transpiler vs. Virtual Machine

- **Interpreter**:
  Interpreter takes the program's AST and executes it directly line by line. This is a simpler approach, but it can be slower than a compiler. The interpreter is especially useful for languages that should work independently of the platform.

  - Examples: Python, Ruby, JavaScript

- **Compiler**:
  Compiler takes the program's AST and translates it into machine code. This machine code can be executed directly by the CPU. This approach is faster than an interpreter because the code is already compiled. However, the compiler is platform-dependent.

  - Examples: C, C++, Rust

- **Transpiler**:
  Transpiler takes the program's AST and translates it into another language. This is useful when you want to convert the code from one language to another. For example, you can convert TypeScript to JavaScript.

  - Examples: TypeScript, Babel

- **Virtual Machine**:
  Virtual Machine takes the program's AST and executes it on a virtual machine. This approach is similar to an interpreter, but the virtual machine is platform-dependent. The virtual machine can be faster than an interpreter because it can optimize the code and perform just-in-time compilation.

  - Examples: Java, C#

In this book, we will take the compiler because when I was trying to build my first language I was not able to find good resources on how to build a compiler.

### Compiler

We have various methods to implement a compiler. One approach is to generate Assembly code and utilize Rust's `std::process::Command` to compile the assembly code using tools like `nasm` or `gcc`. Another option is to directly generate opcodes by using a library for parsing and editing `ELF` files, although this limits us to the ELF standard. However, the most common and widely used approach for building a compiler is to leverage `LLVM`. Languages and compilers such as Clang, Rust, Swift, Julia, and many more rely on LLVM. LLVM is highly advantageous as it not only enables the generation of machine code for the target platform but also offers a plethora of optimization options. Additionally, if you prefer the virtual machine approach, you can also utilize LL*VM* for that purpose.

### LLVM

LLVM is a collection of modular and reusable compiler and toolchain technologies. It is designed to be a common infrastructure for building compilers. LLVM is used in various fields, including programming languages, static analysis, and debugging but also used by tools like `NVIDIA CUDA` or `Apple's Swift`.

LLVM can be found at [llvm.org](https://llvm.org/).